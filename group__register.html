<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ModbusMaster: Modbus Function Codes for Holding/Input Registers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ModbusMaster
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__register.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Modbus Function Codes for Holding/Input Registers</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9ffe845bb045dab15afc02a9e72b8d6e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__register.html#ga9ffe845bb045dab15afc02a9e72b8d6e">ModbusMaster::readHoldingRegisters</a> (uint16_t, uint16_t)</td></tr>
<tr class="memdesc:ga9ffe845bb045dab15afc02a9e72b8d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modbus function 0x03 Read Holding Registers.  <a href="#ga9ffe845bb045dab15afc02a9e72b8d6e"></a><br/></td></tr>
<tr class="separator:ga9ffe845bb045dab15afc02a9e72b8d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9094a4770bf9fac0abe2f34aac3a40ec"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__register.html#ga9094a4770bf9fac0abe2f34aac3a40ec">ModbusMaster::readInputRegisters</a> (uint16_t, uint8_t)</td></tr>
<tr class="memdesc:ga9094a4770bf9fac0abe2f34aac3a40ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modbus function 0x04 Read Input Registers.  <a href="#ga9094a4770bf9fac0abe2f34aac3a40ec"></a><br/></td></tr>
<tr class="separator:ga9094a4770bf9fac0abe2f34aac3a40ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b5510cf862f3d584e393d07cd6ceed"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__register.html#gac3b5510cf862f3d584e393d07cd6ceed">ModbusMaster::writeSingleRegister</a> (uint16_t, uint16_t)</td></tr>
<tr class="memdesc:gac3b5510cf862f3d584e393d07cd6ceed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modbus function 0x06 Write Single Register.  <a href="#gac3b5510cf862f3d584e393d07cd6ceed"></a><br/></td></tr>
<tr class="separator:gac3b5510cf862f3d584e393d07cd6ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c894306b676cc702851e204acaad3e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__register.html#ga53c894306b676cc702851e204acaad3e">ModbusMaster::writeMultipleRegisters</a> (uint16_t, uint16_t)</td></tr>
<tr class="memdesc:ga53c894306b676cc702851e204acaad3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modbus function 0x10 Write Multiple Registers.  <a href="#ga53c894306b676cc702851e204acaad3e"></a><br/></td></tr>
<tr class="separator:ga53c894306b676cc702851e204acaad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd8f8cde67f0a4ee4e7dcae7df3b695"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__register.html#ga0bd8f8cde67f0a4ee4e7dcae7df3b695">ModbusMaster::maskWriteRegister</a> (uint16_t, uint16_t, uint16_t)</td></tr>
<tr class="memdesc:ga0bd8f8cde67f0a4ee4e7dcae7df3b695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modbus function 0x16 Mask Write Register.  <a href="#ga0bd8f8cde67f0a4ee4e7dcae7df3b695"></a><br/></td></tr>
<tr class="separator:ga0bd8f8cde67f0a4ee4e7dcae7df3b695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d764079d29620431fb97003cf54cc7b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__register.html#ga5d764079d29620431fb97003cf54cc7b">ModbusMaster::readWriteMultipleRegisters</a> (uint16_t, uint16_t, uint16_t, uint16_t)</td></tr>
<tr class="memdesc:ga5d764079d29620431fb97003cf54cc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modbus function 0x17 Read Write Multiple Registers.  <a href="#ga5d764079d29620431fb97003cf54cc7b"></a><br/></td></tr>
<tr class="separator:ga5d764079d29620431fb97003cf54cc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9ffe845bb045dab15afc02a9e72b8d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster::readHoldingRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modbus function 0x03 Read Holding Registers. </p>
<p>This function code is used to read the contents of a contiguous block of holding registers in a remote device. The request specifies the starting register address and the number of registers. Registers are addressed starting at zero.</p>
<p>The register data in the response buffer is packed as one word per register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of the first holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16ReadQty</td><td>quantity of holding registers to read (1..125, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2_basic_2_basic_8pde-example.html#a4">examples/Basic/Basic.pde</a>, and <a class="el" href="examples_2_phoenix_contact_nano_l_c_2_phoenix_contact_nano_l_c_8pde-example.html#a8">examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde</a>.</dd>
</dl><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="class_modbus_master.html#adfb48ef6321f738cc4b55c4b6e4a6335" title="slave register from which to read">_u16ReadAddress</a> = u16ReadAddress;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a043a88f0b184accd9176770dee55a6b3" title="quantity of words to read">_u16ReadQty</a> = u16ReadQty;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="class_modbus_master.html#a4c88df0ed38e98457e8ac74c2ed5dc81" title="Modbus transaction engine.">ModbusMasterTransaction</a>(<a class="code" href="class_modbus_master.html#ae6995c167c152d96b06a918869c03623" title="Modbus function 0x03 Read Holding Registers.">ku8MBReadHoldingRegisters</a>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga9094a4770bf9fac0abe2f34aac3a40ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster::readInputRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u16ReadQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modbus function 0x04 Read Input Registers. </p>
<p>This function code is used to read from 1 to 125 contiguous input registers in a remote device. The request specifies the starting register address and the number of registers. Registers are addressed starting at zero.</p>
<p>The register data in the response buffer is packed as one word per register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of the first input register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16ReadQty</td><td>quantity of input registers to read (1..125, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2_phoenix_contact_nano_l_c_2_phoenix_contact_nano_l_c_8pde-example.html#a10">examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde</a>.</dd>
</dl><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="class_modbus_master.html#adfb48ef6321f738cc4b55c4b6e4a6335" title="slave register from which to read">_u16ReadAddress</a> = u16ReadAddress;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a043a88f0b184accd9176770dee55a6b3" title="quantity of words to read">_u16ReadQty</a> = u16ReadQty;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="class_modbus_master.html#a4c88df0ed38e98457e8ac74c2ed5dc81" title="Modbus transaction engine.">ModbusMasterTransaction</a>(<a class="code" href="class_modbus_master.html#aeaa94736b198f6a05cf74e0466afb443" title="Modbus function 0x04 Read Input Registers.">ku8MBReadInputRegisters</a>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gac3b5510cf862f3d584e393d07cd6ceed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster::writeSingleRegister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modbus function 0x06 Write Single Register. </p>
<p>This function code is used to write a single holding register in a remote device. The request specifies the address of the register to be written. Registers are addressed starting at zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16WriteValue</td><td>value to be written to holding register (0x0000..0xFFFF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2_phoenix_contact_nano_l_c_2_phoenix_contact_nano_l_c_8pde-example.html#a4">examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde</a>.</dd>
</dl><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a00edff3fbd53d94dcc1b6be593c61289" title="slave register to which to write">_u16WriteAddress</a> = u16WriteAddress;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#ad3191c5da05cf72e117814ba0472b420" title="quantity of words to write">_u16WriteQty</a> = 0;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a8a79a050ef684f78b06b7543a56f54fb" title="buffer containing data to transmit to Modbus slave; set via SetTransmitBuffer()">_u16TransmitBuffer</a>[0] = u16WriteValue;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="class_modbus_master.html#a4c88df0ed38e98457e8ac74c2ed5dc81" title="Modbus transaction engine.">ModbusMasterTransaction</a>(<a class="code" href="class_modbus_master.html#ab68b007cd9473c3ed09f36fb0f6ee3fa" title="Modbus function 0x06 Write Single Register.">ku8MBWriteSingleRegister</a>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga53c894306b676cc702851e204acaad3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster::writeMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modbus function 0x10 Write Multiple Registers. </p>
<p>This function code is used to write a block of contiguous registers (1 to 123 registers) in a remote device.</p>
<p>The requested written values are specified in the transmit buffer. Data is packed as one word per register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16WriteQty</td><td>quantity of holding registers to write (1..123, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2_basic_2_basic_8pde-example.html#a3">examples/Basic/Basic.pde</a>, and <a class="el" href="examples_2_phoenix_contact_nano_l_c_2_phoenix_contact_nano_l_c_8pde-example.html#a6">examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde</a>.</dd>
</dl><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a00edff3fbd53d94dcc1b6be593c61289" title="slave register to which to write">_u16WriteAddress</a> = u16WriteAddress;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#ad3191c5da05cf72e117814ba0472b420" title="quantity of words to write">_u16WriteQty</a> = u16WriteQty;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="class_modbus_master.html#a4c88df0ed38e98457e8ac74c2ed5dc81" title="Modbus transaction engine.">ModbusMasterTransaction</a>(<a class="code" href="class_modbus_master.html#adf1f58e7806d4c7bc1638255e2639b86" title="Modbus function 0x10 Write Multiple Registers.">ku8MBWriteMultipleRegisters</a>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga0bd8f8cde67f0a4ee4e7dcae7df3b695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster::maskWriteRegister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16AndMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16OrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modbus function 0x16 Mask Write Register. </p>
<p>This function code is used to modify the contents of a specified holding register using a combination of an AND mask, an OR mask, and the register's current contents. The function can be used to set or clear individual bits in the register.</p>
<p>The request specifies the holding register to be written, the data to be used as the AND mask, and the data to be used as the OR mask. Registers are addressed starting at zero.</p>
<p>The function's algorithm is:</p>
<p>Result = (Current Contents &amp;&amp; And_Mask) || (Or_Mask &amp;&amp; (~And_Mask))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16AndMask</td><td>AND mask (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16OrMask</td><td>OR mask (0x0000..0xFFFF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>
<div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a00edff3fbd53d94dcc1b6be593c61289" title="slave register to which to write">_u16WriteAddress</a> = u16WriteAddress;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a8a79a050ef684f78b06b7543a56f54fb" title="buffer containing data to transmit to Modbus slave; set via SetTransmitBuffer()">_u16TransmitBuffer</a>[0] = u16AndMask;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a8a79a050ef684f78b06b7543a56f54fb" title="buffer containing data to transmit to Modbus slave; set via SetTransmitBuffer()">_u16TransmitBuffer</a>[1] = u16OrMask;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="class_modbus_master.html#a4c88df0ed38e98457e8ac74c2ed5dc81" title="Modbus transaction engine.">ModbusMasterTransaction</a>(<a class="code" href="class_modbus_master.html#a1de5e699bcada855fb26e336d2cd2cd3" title="Modbus function 0x16 Mask Write Register.">ku8MBMaskWriteRegister</a>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga5d764079d29620431fb97003cf54cc7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster::readWriteMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadQty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modbus function 0x17 Read Write Multiple Registers. </p>
<p>This function code performs a combination of one read operation and one write operation in a single MODBUS transaction. The write operation is performed before the read. Holding registers are addressed starting at zero.</p>
<p>The request specifies the starting address and number of holding registers to be read as well as the starting address, and the number of holding registers. The data to be written is specified in the transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of the first holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16ReadQty</td><td>quantity of holding registers to read (1..125, enforced by remote device) </td></tr>
    <tr><td class="paramname">u16WriteAddress</td><td>address of the first holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16WriteQty</td><td>quantity of holding registers to write (1..121, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2_phoenix_contact_nano_l_c_2_phoenix_contact_nano_l_c_8pde-example.html#a3">examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde</a>.</dd>
</dl><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="class_modbus_master.html#adfb48ef6321f738cc4b55c4b6e4a6335" title="slave register from which to read">_u16ReadAddress</a> = u16ReadAddress;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a043a88f0b184accd9176770dee55a6b3" title="quantity of words to read">_u16ReadQty</a> = u16ReadQty;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#a00edff3fbd53d94dcc1b6be593c61289" title="slave register to which to write">_u16WriteAddress</a> = u16WriteAddress;</div>
<div class="line">  <a class="code" href="class_modbus_master.html#ad3191c5da05cf72e117814ba0472b420" title="quantity of words to write">_u16WriteQty</a> = u16WriteQty;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="class_modbus_master.html#a4c88df0ed38e98457e8ac74c2ed5dc81" title="Modbus transaction engine.">ModbusMasterTransaction</a>(<a class="code" href="class_modbus_master.html#af1c77f6f5f7e0f19d0c9b9916dca2263" title="Modbus function 0x17 Read Write Multiple Registers.">ku8MBReadWriteMultipleRegisters</a>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
