<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ModbusMaster: examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>examples/PhoenixContact_nanoLC/PhoenixContact_nanoLC.pde</h1><div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"></span>
<span class="comment">  PhoenixContact_nanoLC.pde - example using ModbusMaster library</span>
<span class="comment">  to communicate with PHOENIX CONTACT nanoLine controller.</span>
<span class="comment">  </span>
<span class="comment">  This file is part of ModbusMaster.</span>
<span class="comment">  </span>
<span class="comment">  ModbusMaster is free software: you can redistribute it and/or modify</span>
<span class="comment">  it under the terms of the GNU General Public License as published by</span>
<span class="comment">  the Free Software Foundation, either version 3 of the License, or</span>
<span class="comment">  (at your option) any later version.</span>
<span class="comment">  </span>
<span class="comment">  ModbusMaster is distributed in the hope that it will be useful,</span>
<span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="comment">  GNU General Public License for more details.</span>
<span class="comment">  </span>
<span class="comment">  You should have received a copy of the GNU General Public License</span>
<span class="comment">  along with ModbusMaster.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="comment">  </span>
<span class="comment">  Written by Doc Walker (Rx)</span>
<span class="comment">  Copyright © 2009, 2010 Doc Walker &lt;dfwmountaineers at gmail dot com&gt;</span>
<span class="comment">  $Id: PhoenixContact_nanoLC.pde 29 2010-02-05 03:02:19Z dfwmountaineers $</span>
<span class="comment">  </span>
<span class="comment">*/</span>

<span class="preprocessor">#include &lt;ModbusMaster.h&gt;</span>

<span class="comment">// discrete coils</span>
<span class="preprocessor">#define NANO_DO(n)   (0x0000 + n) </span>
<span class="preprocessor">#define NANO_FLAG(n) (0x1000 + n) </span>
<span class="preprocessor"></span>
<span class="preprocessor"></span><span class="comment">// discrete inputs</span>
<span class="preprocessor">#define NANO_DI(n)   (0x0000 + n) </span>
<span class="preprocessor"></span>
<span class="preprocessor"></span><span class="comment">// analog holding registers</span>
<span class="preprocessor">#define NANO_REG(n)  (0x0000 + 2 * n) </span>
<span class="preprocessor">#define NANO_AO(n)   (0x1000 + 2 * n) </span>
<span class="preprocessor">#define NANO_TCP(n)  (0x2000 + 2 * n) </span>
<span class="preprocessor">#define NANO_OTP(n)  (0x3000 + 2 * n) </span>
<span class="preprocessor">#define NANO_HSP(n)  (0x4000 + 2 * n) </span>
<span class="preprocessor">#define NANO_TCA(n)  (0x5000 + 2 * n) </span>
<span class="preprocessor">#define NANO_OTA(n)  (0x6000 + 2 * n) </span>
<span class="preprocessor">#define NANO_HSA(n)  (0x7000 + 2 * n) </span>
<span class="preprocessor"></span>
<span class="preprocessor"></span><span class="comment">// analog input registers</span>
<span class="preprocessor">#define NANO_AI(n)   (0x0000 + 2 * n) </span>
<span class="preprocessor"></span>
<span class="preprocessor"></span>
<span class="comment">// instantiate ModbusMaster object, serial port 0, Modbus slave ID 1</span>
<a name="_a0"></a><a class="code" href="class_modbus_master.html" title="Arduino class library for communicating with Modbus slaves over RS232/485 (via RTU...">ModbusMaster</a> nanoLC(0, 1);


<span class="keywordtype">void</span> setup()
{
  <span class="comment">// initialize Modbus communication baud rate</span>
  nanoLC.begin(19200);
}


<span class="keywordtype">void</span> loop()
{
  <span class="keyword">static</span> uint32_t u32ShiftRegister;
  <span class="keyword">static</span> uint32_t i;
  uint8_t u8Status;
  
  u32ShiftRegister = ((u32ShiftRegister &lt; 0x01000000) ? (u32ShiftRegister &lt;&lt; 4) : 1);
  <span class="keywordflow">if</span> (u32ShiftRegister == 0) u32ShiftRegister = 1;
  i++;
  
  <span class="comment">// set word 0 of TX buffer to least-significant word of u32ShiftRegister (bits 15..0)</span>
  nanoLC.SetTransmitBuffer(0, lowWord(u32ShiftRegister));
  
  <span class="comment">// set word 1 of TX buffer to most-significant word of u32ShiftRegister (bits 31..16)</span>
  nanoLC.SetTransmitBuffer(1, highWord(u32ShiftRegister));
  
  <span class="comment">// set word 2 of TX buffer to least-significant word of i (bits 15..0)</span>
  nanoLC.SetTransmitBuffer(2, lowWord(i));
  
  <span class="comment">// set word 3 of TX buffer to most-significant word of i (bits 31..16)</span>
  nanoLC.SetTransmitBuffer(3, highWord(i));
  
  <span class="comment">// write TX buffer to (4) 16-bit registers starting at NANO_REG(1)</span>
  <span class="comment">// read (4) 16-bit registers starting at NANO_REG(0) to RX buffer</span>
  <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..3)</span>
  nanoLC.ReadWriteMultipleRegisters(NANO_REG(0), 4, NANO_REG(1), 4);
  
  <span class="comment">// write lowWord(u32ShiftRegister) to single 16-bit register starting at NANO_REG(3)</span>
  nanoLC.WriteSingleRegister(NANO_REG(3), lowWord(u32ShiftRegister));
  
  <span class="comment">// write highWord(u32ShiftRegister) to single 16-bit register starting at NANO_REG(3) + 1</span>
  nanoLC.WriteSingleRegister(NANO_REG(3) + 1, highWord(u32ShiftRegister));
  
  <span class="comment">// set word 0 of TX buffer to nanoLC.GetResponseBuffer(0) (bits 15..0)</span>
  nanoLC.SetTransmitBuffer(0, nanoLC.GetResponseBuffer(0));
  
  <span class="comment">// set word 1 of TX buffer to nanoLC.GetResponseBuffer(1) (bits 31..16)</span>
  nanoLC.SetTransmitBuffer(1, nanoLC.GetResponseBuffer(1));
  
  <span class="comment">// write TX buffer to (2) 16-bit registers starting at NANO_REG(4)</span>
  nanoLC.WriteMultipleRegisters(NANO_REG(4), 2);
  
  <span class="comment">// read 17 coils starting at NANO_FLAG(0) to RX buffer</span>
  <span class="comment">// bits 15..0 are available via nanoLC.GetResponseBuffer(0)</span>
  <span class="comment">// bit 16 is available via zero-padded nanoLC.GetResponseBuffer(1)</span>
  nanoLC.ReadCoils(NANO_FLAG(0), 17);
  
  <span class="comment">// read (66) 16-bit registers starting at NANO_REG(0) to RX buffer</span>
  <span class="comment">// generates Modbus exception ku8MBIllegalDataAddress (0x02)</span>
  u8Status = nanoLC.ReadHoldingRegisters(NANO_REG(0), 66);
  <span class="keywordflow">if</span> (u8Status == nanoLC.ku8MBIllegalDataAddress)
  {
    <span class="comment">// read (64) 16-bit registers starting at NANO_REG(0) to RX buffer</span>
    <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..63)</span>
    u8Status = nanoLC.ReadHoldingRegisters(NANO_REG(0), 64);
  }
  
  <span class="comment">// read (8) 16-bit registers starting at NANO_AO(0) to RX buffer</span>
  <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..7)</span>
  nanoLC.ReadHoldingRegisters(NANO_AO(0), 8);
  
  <span class="comment">// read (64) 16-bit registers starting at NANO_TCP(0) to RX buffer</span>
  <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..63)</span>
  nanoLC.ReadHoldingRegisters(NANO_TCP(0), 64);
  
  <span class="comment">// read (64) 16-bit registers starting at NANO_OTP(0) to RX buffer</span>
  <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..63)</span>
  nanoLC.ReadHoldingRegisters(NANO_OTP(0), 64);
  
  <span class="comment">// read (64) 16-bit registers starting at NANO_TCA(0) to RX buffer</span>
  <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..63)</span>
  nanoLC.ReadHoldingRegisters(NANO_TCA(0), 64);
  
  <span class="comment">// read (64) 16-bit registers starting at NANO_OTA(0) to RX buffer</span>
  <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..63)</span>
  nanoLC.ReadHoldingRegisters(NANO_OTA(0), 64);
  
  <span class="comment">// read (8) 16-bit registers starting at NANO_AI(0) to RX buffer</span>
  <span class="comment">// data is available via nanoLC.GetResponseBuffer(0..7)</span>
  nanoLC.ReadInputRegisters(NANO_AI(0), 8);
}
</pre></div> </div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
